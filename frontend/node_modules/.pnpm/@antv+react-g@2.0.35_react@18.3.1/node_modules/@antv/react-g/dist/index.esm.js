/*!
 * @antv/react-g
 * @description react render for @antv/g
 * @version 2.0.35
 * @date 1/2/2025, 2:58:05 AM
 * @author AntVis
 * @docs https://g.antv.antgroup.com/
 */
import { Shape, Canvas as Canvas$1 } from '@antv/g';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _extends from '@babel/runtime/helpers/extends';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import _callSuper from '@babel/runtime/helpers/callSuper';
import _inherits from '@babel/runtime/helpers/inherits';
import { isBoolean } from '@antv/util';
import { vec3 } from 'gl-matrix';
import React, { Component, forwardRef, useRef, useLayoutEffect } from 'react';
import ReactReconciler from 'react-reconciler';
import { unstable_now } from 'scheduler';

var _excluded = ["startHead", "endHead"],
  _excluded2 = ["startHead", "endHead"];
var DEFAULT_ARROW_SIZE = 16;
var Arrow = /*#__PURE__*/function (_Component) {
  function Arrow(props) {
    var _this;
    _classCallCheck(this, Arrow);
    _this = _callSuper(this, Arrow, [props]);
    _this.startRef = /*#__PURE__*/React.createRef();
    _this.endRef = /*#__PURE__*/React.createRef();
    _this.bodyRef = /*#__PURE__*/React.createRef();
    return _this;
  }
  _inherits(Arrow, _Component);
  return _createClass(Arrow, [{
    key: "getArrowHead",
    value: function getArrowHead(head, isStart) {
      if (isBoolean(head)) {
        return this.getDefaultArrowHead();
      } else {
        return isStart ? this.props.startHead : this.props.endHead;
      }
    }
  }, {
    key: "setHeadTransform",
    value: function setHeadTransform() {
      var _this$props = this.props,
        startHead = _this$props.startHead,
        endHead = _this$props.endHead;
      if (startHead) this.transformArrowHead(this.startRef.current, true);
      if (endHead) this.transformArrowHead(this.endRef.current, false);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setHeadTransform();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.setHeadTransform();
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
        startHead = _this$props2.startHead,
        endHead = _this$props2.endHead,
        others = _objectWithoutProperties(_this$props2, _excluded);
      return /*#__PURE__*/React.createElement(Group, null, /*#__PURE__*/React.createElement(Path, _extends({}, others, {
        ref: this.bodyRef
      })), startHead && /*#__PURE__*/React.createElement(Group, {
        ref: this.startRef
      }, this.getArrowHead(startHead, true)), endHead && /*#__PURE__*/React.createElement(Group, {
        ref: this.endRef
      }, this.getArrowHead(endHead, false)));
    }
  }, {
    key: "getCenter",
    value: function getCenter() {
      var points = this.bodyRef.current.getPoint(0.5);
      return points;
    }

    // transform arrow head to match line tangent
  }, {
    key: "transformArrowHead",
    value: function transformArrowHead(head, isStart) {
      var _this$getTangent = this.getTangent(this.bodyRef.current, isStart),
        _this$getTangent2 = _slicedToArray(_this$getTangent, 2),
        p1 = _this$getTangent2[0],
        p2 = _this$getTangent2[1];
      var _p = _slicedToArray(p1, 2),
        x1 = _p[0],
        y1 = _p[1];
      var _p2 = _slicedToArray(p2, 2),
        x2 = _p2[0],
        y2 = _p2[1];
      var x = x1 - x2;
      var y = y1 - y2;
      var rad = Math.atan2(y, x) + Math.PI;
      var position = vec3.fromValues(x2, y2, 0);
      head.setLocalPosition(position);
      head.setLocalEulerAngles(rad * 180 / Math.PI);
    }
  }, {
    key: "getTangent",
    value: function getTangent(path, isStart) {
      return isStart ? path.getStartTangent() : path.getEndTangent();
    }
  }, {
    key: "getDefaultArrowHead",
    value: function getDefaultArrowHead() {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      var _this$props3 = this.props;
        _this$props3.startHead;
        _this$props3.endHead;
        var others = _objectWithoutProperties(_this$props3, _excluded2);
      var sin = Math.sin,
        cos = Math.cos,
        PI = Math.PI;
      return /*#__PURE__*/React.createElement(Path, _extends({}, others, {
        lineDash: undefined,
        fill: this.props.stroke,
        d: "M-".concat(DEFAULT_ARROW_SIZE * cos(PI / 6), ",").concat(DEFAULT_ARROW_SIZE * sin(PI / 6), " L0,0 L-").concat(DEFAULT_ARROW_SIZE * cos(PI / 6), ",-").concat(DEFAULT_ARROW_SIZE * sin(PI / 6), " Z")
      }));
    }
  }]);
}(Component);

function ElementOf(type) {
  return type;
}
var Circle = ElementOf(Shape.CIRCLE);
var Ellipse = ElementOf(Shape.ELLIPSE);
var Group = ElementOf(Shape.GROUP);
var HTML = ElementOf(Shape.HTML);
var Image = ElementOf(Shape.IMAGE);
var Line = ElementOf(Shape.LINE);
var Path = ElementOf(Shape.PATH);
var Polygon = ElementOf(Shape.POLYGON);
var Polyline = ElementOf(Shape.POLYLINE);
var Rect = ElementOf(Shape.RECT);
var Text = ElementOf(Shape.TEXT);

var zIndexWarningShowed = false;
var Z_INDEX_WARNING = "ReactG: You are using \"zIndex\" attribute for an element.\nreact-g may get confused with ordering. Just define correct order of elements in your render function of a component.\n";
var isEvent = function isEvent(key) {
  return key.slice(0, 2) === 'on';
};
var getEventName = function getEventName(key) {
  return key.substring(2).toLowerCase();
};
var bindShapeEvent = function bindShapeEvent(newProps, instance) {
  Object.keys(newProps).forEach(function (propKey) {
    if (isEvent(propKey)) {
      instance.addEventListener(getEventName(propKey), newProps[propKey]);
    }
  });
};
var updateProps = function updateProps(instance, newProps) {
  var oldProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // don't use zIndex
  if (!zIndexWarningShowed && 'zIndex' in newProps) {
    console.warn(Z_INDEX_WARNING);
    zIndexWarningShowed = true;
  }
  Object.keys(oldProps).forEach(function (key) {
    var propChanged = oldProps[key] !== newProps[key];
    if (propChanged) {
      if (isEvent(key)) {
        instance.removeEventListener(getEventName(key));
      } else {
        instance.removeAttribute(key);
      }
    }
  });
  Object.keys(newProps).forEach(function (key) {
    var propChanged = oldProps[key] !== newProps[key];
    if (propChanged) {
      if (isEvent(key)) {
        if (typeof newProps[key] === 'function') {
          instance.addEventListener(getEventName(key), newProps[key]);
        }
      } else {
        instance.setAttribute(key, newProps[key]);
      }
    }
  });
};

var reconciler = ReactReconciler({
  getPublicInstance: function getPublicInstance(instance) {
    return instance;
  },
  getRootHostContext: function getRootHostContext(rootContainerInstance) {},
  getChildHostContext: function getChildHostContext(parentHostContext, type, rootContainerInstance) {},
  prepareForCommit: function prepareForCommit(containerInfo) {
    return null;
  },
  resetAfterCommit: function resetAfterCommit(containerInfo) {},
  preparePortalMount: function preparePortalMount(containerInfo) {},
  createInstance: function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
    var instance = (rootContainerInstance.document || rootContainerInstance.ownerDocument).createElement(type, {
      style: props
    });
    // @ts-ignore
    bindShapeEvent(props, instance);
    // log('createInstance ', type, instance);
    // @ts-ignore
    return instance;
  },
  appendInitialChild: function appendInitialChild(parentInstance, child) {
    // log('appendInitialChild', parentInstance, child);
    parentInstance.appendChild(child);
  },
  finalizeInitialChildren: function finalizeInitialChildren(parentInstance, type, props, rootContainerInstance, hostContext) {
    return false;
  },
  prepareUpdate: function prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, hostContext) {
    // return hasUpdate(newProps, oldProps);
    return true;
  },
  shouldSetTextContent: function shouldSetTextContent(type, props) {
    return false;
  },
  // shouldDeprioritizeSubtree(type: Type, props: Props): boolean {
  //   return false;
  // },
  createTextInstance: function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle
  // @ts-ignore
  ) {},
  // scheduleDeferredCallback(callback: () => any, options?: { timeout: number }): any {},
  // scheduleDeferredCallback,
  // cancelDeferredCallback(callbackID: any): void {},
  scheduleTimeout: function scheduleTimeout(handler, timeout) {},
  cancelTimeout: function cancelTimeout(handle) {},
  noTimeout: undefined,
  now: unstable_now,
  // Temporary workaround for scenario where multiple renderers concurrently
  // render using the same context objects. E.g. React DOM and React ART on the
  // same page. DOM is the primary renderer {}, ART is the secondary renderer.
  isPrimaryRenderer: false,
  supportsMutation: true,
  supportsPersistence: false,
  supportsHydration: false,
  // -------------------
  //      Mutation
  //     (optional)
  // -------------------
  appendChild: function appendChild(parentInstance, child) {
    // log('appendChild');
    parentInstance.appendChild(child);
  },
  appendChildToContainer: function appendChildToContainer(container, child) {
    // log('appendChildToContainer', container, child);
    container.appendChild(child);
  },
  commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {},
  commitMount: function commitMount(instance, type, newProps, internalInstanceHandle) {},
  commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
    // log('commitUpdate', instance, newProps);
    updateProps(instance, newProps, oldProps);
  },
  insertBefore: function insertBefore(parentInstance, child, beforeChild) {
    parentInstance.insertBefore(child, beforeChild);
  },
  insertInContainerBefore: function insertInContainerBefore(container, child, beforeChild) {
    container.insertBefore(child, beforeChild);
  },
  removeChild: function removeChild(parentInstance, child) {
    // log('removeChild', parentInstance, child);
    parentInstance.removeChild(child);
  },
  removeChildFromContainer: function removeChildFromContainer(container, child) {
    container.removeChild(child);
  },
  resetTextContent: function resetTextContent(instance) {},
  /**
   * This method should make the `instance` invisible without removing it from the tree. For example, it can apply visual styling to hide it. It is used by Suspense to hide the tree while the fallback is visible.
   */
  // tslint:enable:max-line-length
  hideInstance: function hideInstance(instance) {},
  /**
   * Same as `hideInstance`, but for nodes created by `createTextInstance`.
   */
  hideTextInstance: function hideTextInstance(textInstance) {},
  /**
   * This method should make the `instance` visible, undoing what `hideInstance` did.
   */
  // @ts-ignore
  unhideInstance: function unhideInstance(instance, props) {},
  /**
   * Same as `unhideInstance`, but for nodes created by `createTextInstance`.
   */
  // @ts-ignore
  unhideTextInstance: function unhideTextInstance(textInstance, text) {},
  /**
   * This method should mutate the `container` root node and remove all children from it.
   */
  clearContainer: function clearContainer(container) {
    container.removeChildren();
  },
  // -------------------
  //     Persistence
  //     (optional)
  // -------------------
  cloneInstance: function cloneInstance(instance, updatePayload, type, oldProps, newProps, internalInstanceHandle, keepChildren, recyclableInstance) {
    return instance;
  },
  createContainerChildSet: function createContainerChildSet(container) {},
  appendChildToContainerChildSet: function appendChildToContainerChildSet(childSet, child) {},
  finalizeContainerChildren: function finalizeContainerChildren(container, newChildren) {},
  replaceContainerChildren: function replaceContainerChildren(container, newChildren) {},
  // -------------------
  //     Hydration
  //     (optional)
  // -------------------
  canHydrateInstance: function canHydrateInstance(instance, type, props) {
    return instance;
  },
  canHydrateTextInstance: function canHydrateTextInstance(instance, text) {
    return null;
  },
  getNextHydratableSibling: function getNextHydratableSibling(instance) {},
  getFirstHydratableChild: function getFirstHydratableChild(parentInstance) {},
  hydrateInstance: function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {},
  hydrateTextInstance: function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
    return false;
  },
  didNotMatchHydratedContainerTextInstance: function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {},
  didNotMatchHydratedTextInstance: function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {},
  didNotHydrateContainerInstance: function didNotHydrateContainerInstance(parentContainer, instance) {},
  didNotHydrateInstance: function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {},
  didNotFindHydratableContainerInstance: function didNotFindHydratableContainerInstance(parentContainer, type, props) {},
  didNotFindHydratableContainerTextInstance: function didNotFindHydratableContainerTextInstance(parentContainer, text) {},
  didNotFindHydratableInstance: function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {},
  didNotFindHydratableTextInstance: function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {}
});
reconciler.injectIntoDevTools({
  // findFiberByHostInstance: () => {},
  // @ts-ignore
  bundleType: 1 ,
  version: React.version,
  rendererPackageName: 'react-g',
  rendererConfig: {
    getInspectorDataForViewTag: function getInspectorDataForViewTag(tag) {
      // console.log(tag);
    }
  }
});
var TargetContainerWeakMap = new WeakMap();

/**
 * render react-g component to target g element
 * 将react-g组件渲染到任意的g实例（Canvas/Group/Shape）中
 * @param component react-g component
 * @param target g element, Canvas/Group/Shape instance
 * @param callback callback after render finished
 * @returns void
 */
var render = function render(component, target, callback) {
  var container = TargetContainerWeakMap.get(target) || reconciler.createContainer(target, 1, false, null);
  TargetContainerWeakMap.set(target, container);
  reconciler.updateContainer(component, container, null, callback);
};

function assertRef(forwardedRef) {
  if (typeof forwardedRef === 'function') {
    throw new Error('Callback ref not support!');
  }
}

var Canvas = /*#__PURE__*/forwardRef(function (_ref, ref) {
  var children = _ref.children,
    classname = _ref.classname,
    role = _ref.role,
    style = _ref.style,
    tabIndex = _ref.tabIndex,
    title = _ref.title,
    renderer = _ref.renderer,
    width = _ref.width,
    height = _ref.height,
    capture = _ref.capture,
    cursor = _ref.cursor;
  assertRef(ref);
  var container = useRef();
  var divRef = useRef(null);
  var innerCanvasRef = useRef(null);
  var canvasRef = ref || innerCanvasRef;
  useLayoutEffect(function () {
    var canvas = new Canvas$1({
      renderer: renderer,
      width: width,
      height: height,
      capture: capture,
      cursor: cursor,
      container: divRef.current
    });
    canvasRef.current = canvas;

    // @ts-ignore
    container.current = reconciler.createContainer(canvas, 1, false, null);
    return function () {
      // @ts-ignore
      reconciler.updateContainer(null, container.current, null);
    };
  }, []);
  useLayoutEffect(function () {
    if (container.current) {
      // @ts-ignore
      reconciler.updateContainer(children, container.current, null);
    }
  }, [children]);
  useLayoutEffect(function () {
    var _canvasRef$current;
    (_canvasRef$current = canvasRef.current) === null || _canvasRef$current === void 0 || _canvasRef$current.setRenderer(renderer);
  }, [canvasRef, renderer]);
  useLayoutEffect(function () {
    var _canvasRef$current2;
    (_canvasRef$current2 = canvasRef.current) === null || _canvasRef$current2 === void 0 || _canvasRef$current2.setCursor(cursor);
  }, [canvasRef, cursor]);
  useLayoutEffect(function () {
    canvasRef.current.resize(width, height);
  }, [width, height, canvasRef]);
  return /*#__PURE__*/React.createElement("div", {
    ref: divRef,
    className: classname,
    role: role,
    style: style,
    tabIndex: tabIndex,
    title: title
  });
});

export { Arrow, Canvas, Circle, ElementOf, Ellipse, Group, HTML, Image, Line, Path, Polygon, Polyline, Rect, Text, reconciler, render };
//# sourceMappingURL=index.esm.js.map
