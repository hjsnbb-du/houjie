"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReadyEventEmitter = exports.Ready = void 0;
const node_events_1 = require("node:events");
class Ready {
    #isReady;
    #readyCallbacks;
    #readyError;
    constructor() {
        this.#isReady = false;
        this.#readyCallbacks = [];
    }
    ready(flagOrFunction) {
        // register a callback
        if (flagOrFunction === undefined || typeof flagOrFunction === 'function') {
            return this.#register(flagOrFunction);
        }
        // get ready and emit callbacks
        this.#emit(flagOrFunction);
    }
    get isReady() {
        return this.#isReady;
    }
    get readyError() {
        return this.#readyError;
    }
    get hasReadyCallbacks() {
        return this.#readyCallbacks.length > 0;
    }
    /**
     * Register a callback to the callback stack, it will be called when emit.
     * It will return promise when no argument passing.
     */
    #register(func) {
        // support `this.ready().then(onReady)` and `await this.ready()`
        if (!func) {
            return new Promise((resolve, reject) => {
                function func(err) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                }
                if (this.#isReady) {
                    return func(this.#readyError);
                }
                this.#readyCallbacks.push(func);
            });
        }
        // this.ready(fn)
        if (this.#isReady) {
            func(this.#readyError);
        }
        else {
            this.#readyCallbacks.push(func);
        }
    }
    /**
     * Call the callbacks that has been registered, and clean the callback stack.
     * If the flag is not false, it will be marked as ready. Then the callbacks will be called immediately when register.
     * @param {Boolean|Error} flag - Set a flag whether it had been ready. If the flag is an error, it's also ready, but the callback will be called with argument `error`
     */
    #emit(flag) {
        // this.ready(true)
        // this.ready(err)
        // this.ready(false)
        this.#isReady = flag !== false;
        this.#readyError = flag instanceof Error ? flag : undefined;
        // this.ready(true) or this.ready(err)
        if (this.#isReady) {
            this.#readyCallbacks
                .splice(0, Infinity)
                .forEach(callback => process.nextTick(() => callback(this.#readyError)));
        }
    }
    /**
     * @param {Object} obj - an object that be mixed
     */
    static mixin(obj) {
        if (!obj)
            return;
        const readyObject = new Ready();
        // delegate method
        obj.ready = (flagOrFunction) => {
            return readyObject.ready(flagOrFunction);
        };
    }
}
exports.Ready = Ready;
exports.default = Ready;
/**
 * EventEmitter Ready Wrapper
 */
class ReadyEventEmitter extends node_events_1.EventEmitter {
    #readyObj = new Ready();
    ready(flagOrFunction) {
        if (flagOrFunction === undefined) {
            return this.#readyObj.ready();
        }
        this.#readyObj.ready(flagOrFunction);
    }
    get isReady() {
        return this.#readyObj.isReady;
    }
    get readyError() {
        return this.#readyObj.readyError;
    }
    get hasReadyCallbacks() {
        return this.#readyObj.hasReadyCallbacks;
    }
}
exports.ReadyEventEmitter = ReadyEventEmitter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNkNBQTJDO0FBSzNDLE1BQWEsS0FBSztJQUNoQixRQUFRLENBQVU7SUFDbEIsZUFBZSxDQUFxQjtJQUNwQyxXQUFXLENBQVM7SUFFcEI7UUFDRSxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztRQUN0QixJQUFJLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQztJQUM1QixDQUFDO0lBSUQsS0FBSyxDQUFDLGNBQWlDO1FBQ3JDLHNCQUFzQjtRQUN0QixJQUFJLGNBQWMsS0FBSyxTQUFTLElBQUksT0FBTyxjQUFjLEtBQUssVUFBVSxFQUFFLENBQUM7WUFDekUsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3hDLENBQUM7UUFDRCwrQkFBK0I7UUFDL0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQsSUFBSSxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxJQUFJLFVBQVU7UUFDWixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQztJQUVELElBQUksaUJBQWlCO1FBQ25CLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxTQUFTLENBQUMsSUFBdUI7UUFDL0IsZ0VBQWdFO1FBQ2hFLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNWLE9BQU8sSUFBSSxPQUFPLENBQU8sQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7Z0JBQzNDLFNBQVMsSUFBSSxDQUFDLEdBQVc7b0JBQ3ZCLElBQUksR0FBRyxFQUFFLENBQUM7d0JBQ1IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUNk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